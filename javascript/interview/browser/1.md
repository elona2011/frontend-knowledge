* 为什么有跨域
* 跨域方法
* DOM查询
* script defer vs async
* 跨页面通信
* 服务端推送
* Event Loop
* setTimeout vs setImmediate
* 浏览器的工作原理

---

* 为什么有跨域
* 跨域方法

jsonp/form/CORS/nginx

空iframe+form,form.target设为iframe.name

* DOM查询

postMessage/document.domain

* script defer vs async

defer: DOMContentLoaded后执行，保证执行顺序
async: 不保证执行顺序，下载完就执行

* 跨页面通信

同源页面：BroadcastChannel/ServiceWorker/LocalStorage/SharedWorker/IndexDB/Cookie
非同源：iframe/后端

* 服务端推送

轮循/Comet/SSE/WS

Comet:服务端故意不返回数据，浏览器pending
SSE:server-side event/通过EventSource对象实现

* Event Loop

MacroTask：script/setTimeout/IO/Event/setImmediate
MicroTask：Promise/process.nextTick

```js
console.log('start');

setTimeout(function() {
  console.log('timeout1');
}, 10);

new Promise(resolve => {
    console.log('promise1');
    resolve();
    setTimeout(() => console.log('timeout2'), 10);
}).then(function() {
    console.log('then1')
})

console.log('end');
//start promise1 end then1 timeout1 timeout2
```

* setTimeout vs setImmediate

timers/poll/check：timers执行setTimeout/check执行setImmediate/poll执行IO
setTimeout设置为0，其实际值也至少为1，多层嵌套下可能为4ms。为了优化性能及功耗
setTimeout和setImmediate在nodejs中插入的phase不一样，而setTimeout会有最小为1的值，所以一般情况setImmediate会比setTimeout快。但有时EventLoop一个循环超过1ms时，这时就会有setTimeout先于setImmediate执行。

* 浏览器的工作原理

DNS查找/TCP Handshake/TLS协商/响应/TCP慢启动14kb/构建DOM树/预加载扫描/构建CSSOM树/AST/Render树/Layout/Paint/Compositing

https://developer.mozilla.org/zh-CN/docs/Web/Performance/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86