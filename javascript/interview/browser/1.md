* 为什么有跨域
* 跨域方法
* script defer vs async
* 跨页面通信
* 服务端推送
* Event Loop
* setTimeout vs setImmediate
* 浏览器的工作原理
* 重绘 回流

---

* 为什么有跨域

网络请求/DOM查询/内部存储Cookie

* 跨域方法

jsonp/form/CORS/nginx
空iframe+form,form.target设为iframe.name
DOM查询：postMessage/document.domain

* script defer vs async

defer: DOMContentLoaded后执行，保证执行顺序
async: 不保证执行顺序，下载完就执行

* 跨页面通信

同源页面：BroadcastChannel/ServiceWorker/LocalStorage/SharedWorker/IndexDB/Cookie
非同源：iframe/后端

* 服务端推送

轮循/Comet/SSE/WS

Comet:服务端故意不返回数据，浏览器pending
SSE:server-side event/通过EventSource对象实现

* Event Loop

MacroTask：script/setTimeout/IO/Event/setImmediate
MicroTask：Promise/process.nextTick

```js
console.log('start');

setTimeout(function() {
  console.log('timeout1');
}, 10);

new Promise(resolve => {
    console.log('promise1');
    resolve();
    setTimeout(() => console.log('timeout2'), 10);
}).then(function() {
    console.log('then1')
})

console.log('end');
//start promise1 end then1 timeout1 timeout2
```

* setTimeout vs setImmediate

timers/poll/check：timers执行setTimeout/check执行setImmediate/poll执行IO
setTimeout设置为0，其实际值也至少为1，多层嵌套下可能为4ms。为了优化性能及功耗
setTimeout和setImmediate在nodejs中插入的phase不一样，而setTimeout会有最小为1的值，所以一般情况setImmediate会比setTimeout快。但有时EventLoop一个循环超过1ms时，这时就会有setTimeout先于setImmediate执行。

* 浏览器的工作原理

DNS查找/TCP Handshake/TLS协商/响应/TCP慢启动14kb/构建DOM树/预加载扫描/构建CSSOM树/AST/Render树/Layout/Paint/Compositing

https://developer.mozilla.org/zh-CN/docs/Web/Performance/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86

* 重绘 回流

repaint：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少
reflow：当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。
页面初次渲染/窗口大小改变/元素尺寸、位置、内容改变/字体大小/添加或者删除可见元素/查询某些属性或调用某些方法
getComputedStyle/getBoundingClientRect

动画效果应用到absolute或fixed的元素上/DOM使用documentFragment一次性插入，减少操作次数